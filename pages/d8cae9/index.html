<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>01.Buffer的神秘面纱 | Lyc&#39;s blog </title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/blog/assets/css/0.styles.37fe0390.css" as="style"><link rel="preload" href="/blog/assets/js/app.4a3d1442.js" as="script"><link rel="preload" href="/blog/assets/js/2.e2e64146.js" as="script"><link rel="preload" href="/blog/assets/js/23.998636e7.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.2235f657.js"><link rel="prefetch" href="/blog/assets/js/11.f5ad667a.js"><link rel="prefetch" href="/blog/assets/js/12.0e01683e.js"><link rel="prefetch" href="/blog/assets/js/13.3128a710.js"><link rel="prefetch" href="/blog/assets/js/14.c5e78275.js"><link rel="prefetch" href="/blog/assets/js/15.5905ce1e.js"><link rel="prefetch" href="/blog/assets/js/16.9f119347.js"><link rel="prefetch" href="/blog/assets/js/17.679c41e1.js"><link rel="prefetch" href="/blog/assets/js/18.8e903e8e.js"><link rel="prefetch" href="/blog/assets/js/19.1292f262.js"><link rel="prefetch" href="/blog/assets/js/20.90095401.js"><link rel="prefetch" href="/blog/assets/js/21.6a7bdc85.js"><link rel="prefetch" href="/blog/assets/js/22.ca5c587e.js"><link rel="prefetch" href="/blog/assets/js/24.eb30b92b.js"><link rel="prefetch" href="/blog/assets/js/25.d8c8c9e6.js"><link rel="prefetch" href="/blog/assets/js/26.9103af9c.js"><link rel="prefetch" href="/blog/assets/js/27.cc8d9d34.js"><link rel="prefetch" href="/blog/assets/js/3.af9ad256.js"><link rel="prefetch" href="/blog/assets/js/4.66980020.js"><link rel="prefetch" href="/blog/assets/js/5.01d9d731.js"><link rel="prefetch" href="/blog/assets/js/6.c52e28fc.js"><link rel="prefetch" href="/blog/assets/js/7.69a71270.js"><link rel="prefetch" href="/blog/assets/js/8.842597f7.js"><link rel="prefetch" href="/blog/assets/js/9.90677151.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.37fe0390.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Lyc's blog </span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/web/" class="nav-link">前端</a></div><div class="nav-item"><a href="/blog/ui/" class="nav-link">页面</a></div><div class="nav-item"><a href="/blog/technology/" class="nav-link">技术</a></div> <a href="https://github.com/lyc2014/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/blog/imgs/avatar.jpg"> <div class="blogger-info"><h3>Leonardo</h3> <span>前端界的小学生</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/web/" class="nav-link">前端</a></div><div class="nav-item"><a href="/blog/ui/" class="nav-link">页面</a></div><div class="nav-item"><a href="/blog/technology/" class="nav-link">技术</a></div> <a href="https://github.com/lyc2014/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>原理知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>NodeJs</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/d8cae9/" aria-current="page" class="active sidebar-link">01.Buffer的神秘面纱</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/d8cae9/#buffer的神秘面纱" class="sidebar-link">Buffer的神秘面纱</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#buffer初识" class="sidebar-link">Buffer初识</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#什么是二进制数据" class="sidebar-link">什么是二进制数据？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#什么是-stream" class="sidebar-link">什么是 Stream？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#什么是-buffer" class="sidebar-link">什么是 Buffer？</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#buffer-字符编码" class="sidebar-link">Buffer 字符编码</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#buffer内存机制" class="sidebar-link">Buffer内存机制</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#buffer内存分配原理" class="sidebar-link">Buffer内存分配原理</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#buffer-内存分配总结" class="sidebar-link">Buffer 内存分配总结</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#buffer应用场景" class="sidebar-link">Buffer应用场景</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#buffer-vs-cache" class="sidebar-link">Buffer VS Cache</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/d8cae9/#buffer-vs-string" class="sidebar-link">Buffer VS String</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/technology/#技术" data-v-06225672>技术</a></li><li data-v-06225672><a href="/blog/technology/#NodeJs" data-v-06225672>NodeJs</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/lyc2014" target="_blank" title="作者" class="beLink" data-v-06225672>liyuancheng</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-02-22</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">01.Buffer的神秘面纱<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="buffer的神秘面纱"><a href="#buffer的神秘面纱" class="header-anchor">#</a> Buffer的神秘面纱</h2> <ul><li>Buffer初识
<ul><li>什么是二进制数据？</li> <li>什么是Stream？</li> <li>什么是Buffer？</li></ul></li> <li>Buffer的基本使用
<ul><li>Buffer字符编码</li></ul></li> <li>Buffer内存机制
<ul><li>Buffer内存分配原理</li> <li>8KB限制</li> <li>透过buffer.js源码了解Buffer对象分配</li> <li>Buffer内存分配总结</li></ul></li> <li>Buffer应用场景
<ul><li>I/O操作</li> <li>zlib.js</li> <li>加解密</li></ul></li> <li>Buffer VS Cache</li> <li>Buffer VS String</li></ul> <h3 id="buffer初识"><a href="#buffer初识" class="header-anchor">#</a> Buffer初识</h3> <p>在引入 TypedArray 之前，JavaScript 语言没有用于读取或操作二进制数据流的机制。 Buffer 类是作为 Node.js API 的一部分引入的，用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互。这是来自 Node.js 官网的一段描述，比较晦涩难懂，总结起来一句话 <strong>Node.js 可以用来处理二进制流数据或者与之进行交互</strong>。</p> <p>Buffer 用于读取或操作二进制数据流，做为 Node.js API 的一部分使用时无需 require，用于操作网络协议、数据库、图片和文件 I/O 等一些需要大量二进制数据的场景。Buffer 在创建时大小已经被确定且是无法调整的，在内存分配这块 Buffer 是由 C++ 层面提供而不是 V8 具体后面会讲解。</p> <p>在这里不知道你是否认为这是很简单的？但是上面提到的一些关键词 二进制、 流（Stream）、 缓冲区（Buffer），这些又都是什么呢？下面尝试做一些简单的介绍。</p> <h3 id="什么是二进制数据"><a href="#什么是二进制数据" class="header-anchor">#</a> 什么是二进制数据？</h3> <p>谈到二进制我们大脑可能会浮想到就是 010101 这种代码命令，如下图所示：</p> <p><img src="/blog/imgs/03%E6%8A%80%E6%9C%AF/nodebuffer/1.webp" alt="alt text"></p> <p>正如上图所示，二进制数据使用 0 和 1 两个数码来表示的数据，为了存储或展示一些数据，计算机需要先将这些数据转换为二进制来表示。例如，我想存储 66 这个数字，计算机会先将数字 66 转化为二进制 01000010 表示，印象中第一次接触这个是在大学期间 C 语言课程中，转换公式如下所示：</p> <p>128643216842101000010</p> <p>上面用数字举了一个示例，我们知道数字只是数据类型之一，其它的还有字符串、图像、文件等。例如我们对一个英文 M 操作，在 JavaScript 里通过 'M'.charCodeAt() 取到对应的 ASCII 码之后（通过以上的步骤）会转为二进制表示。</p> <h3 id="什么是-stream"><a href="#什么是-stream" class="header-anchor">#</a> 什么是 Stream？</h3> <p>流，英文 Stream 是对输入输出设备的抽象，这里的设备可以是文件、网络、内存等。</p> <p>流是有方向性的，当程序从某个数据源读入数据，会开启一个输入流，这里的数据源可以是文件或者网络等，例如我们从 a.txt 文件读入数据。相反的当我们的程序需要写出数据到指定数据源（文件、网络等）时，则开启一个输出流。当有一些大文件操作时，我们就需要 Stream 像管道一样，一点一点的将数据流出。</p> <p><strong>举个例子</strong></p> <p>我们现在有一大罐水需要浇一片菜地，如果我们将水罐的水一下全部倒入菜地，首先得需要有多么大的力气（这里的力气好比计算机中的硬件性能）才可搬得动。如果，我们拿来了水管将水一点一点流入我们的菜地，这个时候不要这么大力气就可完成。</p> <p><img src="/blog/imgs/03%E6%8A%80%E6%9C%AF/nodebuffer/2.webp" alt="alt text"></p> <p>通过上面的讲解进一步的理解了 Stream 是什么？那么 Stream 和 Buffer 之间又是什么关系呢？看以下介绍，关于 Stream 本身也有很多知识点，欢迎关注公众号「Nodejs技术栈」，之后会单独进行介绍。</p> <h3 id="什么是-buffer"><a href="#什么是-buffer" class="header-anchor">#</a> 什么是 Buffer？</h3> <p>通过以上 Stream 的讲解，我们已经看到数据是从一端流向另一端，那么他们是如何流动的呢？</p> <p>通常，数据的移动是为了处理或者读取它，并根据它进行决策。伴随着时间的推移，每一个过程都会有一个最小或最大数据量。如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理。</p> <p>这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 RAM 中。这些概念可能会很难理解，不要担心下面通过一个例子进一步说明。</p> <p><strong>公共汽车站乘车例子</strong></p> <p>举一个公共汽车站乘车的例子，通常公共汽车会每隔几十分钟一趟，在这个时间到达之前就算乘客已经满了，车辆也不会提前发车，早到的乘客就需要先在车站进行等待。假设到达的乘客过多，后到的一部分则需要在公共汽车站等待下一趟车驶来。</p> <p><img src="/blog/imgs/03%E6%8A%80%E6%9C%AF/nodebuffer/3.webp" alt="alt text"></p> <h3 id="buffer-字符编码"><a href="#buffer-字符编码" class="header-anchor">#</a> Buffer 字符编码</h3> <p>通过使用字符编码，可实现 Buffer 实例与 JavaScript 字符串之间的相互转换，目前所支持的字符编码如下所示：</p> <ul><li>'ascii' - 仅适用于 7 位 ASCII 数据。此编码速度很快，如果设置则会剥离高位。</li> <li>'utf8' - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8。</li> <li>'utf16le' - 2 或 4 个字节，小端序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li> <li>'ucs2' - 'utf16le' 的别名。</li> <li>'base64' - Base64 编码。当从字符串创建 Buffer 时，此编码也会正确地接受 RFC 4648 第 5 节中指定的 “URL 和文件名安全字母”。</li> <li>'latin1' - 一种将 Buffer 编码成单字节编码字符串的方法（由 RFC 1345 中的 IANA 定义，第 63 页，作为 Latin-1 的补充块和 C0/C1 控制码）。'binary' - 'latin1' 的别名。</li> <li>'hex' - 将每个字节编码成两个十六进制的字符。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> buf <span class="token operator">=</span>Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">,</span><span class="token string">'ascii'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 68656c6c6f20776f726c64</span>
</code></pre></div><h3 id="buffer内存机制"><a href="#buffer内存机制" class="header-anchor">#</a> Buffer内存机制</h3> <p>在 Nodejs 中的 内存管理和 V8 垃圾回收机制 一节主要讲解了在 Node.js 的垃圾回收中主要使用 V8 来管理，但是并没有提到 Buffer 类型的数据是如何回收的，下面让我们来了解 Buffer 的内存回收机制。</p> <p>由于 Buffer 需要处理的是大量的二进制数据，假如用一点就向系统去申请，则会造成频繁的向系统申请内存调用，所以 Buffer 所占用的内存<strong>不再由 V8 分配</strong>，而是在 Node.js 的 <strong>C++ 层面完成申请</strong>，在 <strong>JavaScript 中进行内存分配</strong>。因此，这部分内存我们称之为<strong>堆外内存</strong>。</p> <p><strong>Buffer</strong>是一个典型的<strong>javascript</strong>与<strong>C++<strong>结合的模块，与性能有关的用 <strong>C++<strong>来实现，<strong>javascript</strong> 负责衔接和提供接口。<strong>Buffer</strong>所占的内存不是</strong>V8</strong>堆内存，是独立于</strong>V8</strong>堆内存之外的内存，通过<strong>C++<strong>层面实现内存申请（可以说真正的内存是</strong>C++<strong>层面提供的）、<strong>javascript</strong> 分配内存（可以说</strong>JavaScript</strong>层面只是使用它）。<strong>Buffer</strong>在分配内存最终是使用<strong>ArrayBuffer</strong>对象作为载体。简单点而言， 就是<strong>Buffer</strong>模块使用<strong>v8::ArrayBuffer</strong>分配一片内存，通过<strong>TypedArray</strong>中的<strong>v8::Uint8Array</strong>来去写数据。</p> <h3 id="buffer内存分配原理"><a href="#buffer内存分配原理" class="header-anchor">#</a> Buffer内存分配原理</h3> <p>Node.js 采用了 slab 机制进行预先申请、事后分配，是一种动态的管理机制。</p> <p>使用 Buffer.alloc(size) 传入一个指定的 size 就会申请一块固定大小的内存区域，slab 具有如下三种状态：</p> <ul><li>full：完全分配状态</li> <li>partial：部分分配状态</li> <li>empty：没有被分配状态</li></ul> <p><strong>8KB 限制</strong></p> <p>Node.js 以 8KB 为界限来区分是小对象还是大对象，在 buffer.js 中可以看到以下代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Buffer<span class="token punctuation">.</span>poolSize <span class="token operator">=</span><span class="token number">8</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">// 102 行，Node.js 版本为 v10.x</span>
</code></pre></div><p>Buffer在创建时大小已经被确定且是无法调整的 到这里应该就明白了。</p> <p><strong>分配小内存</strong></p> <p>说道 Buffer 的内存分配就不得不说<strong>Buffer</strong>的<strong>8KB</strong>的问题，对应<strong>buffer.js</strong>源码里面的处理如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Buffer<span class="token punctuation">.</span>poolSize <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FastBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&lt;</span> Buffer<span class="token punctuation">.</span>poolSize <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span> <span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> poolSize <span class="token operator">-</span> poolOffset<span class="token punctuation">)</span>
            <span class="token function">createPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> b <span class="token operator">=</span> allocPool<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>poolOffset<span class="token punctuation">,</span>poolOffset <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        poolOffset <span class="token operator">+=</span> size<span class="token punctuation">;</span>
        <span class="token function">alignPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">createUnsafeBuffer</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>源码直接看来就是以 8KB 作为界限，如果写入的数据大于 8KB 一半的话直接则直接去分配内存，如果小于 4KB 的话则从当前分配池里面判断是否够空间放下当前存储的数据，如果不够则重新去申请 8KB 的内存空间，把数据存储到新申请的空间里面，如果足够写入则直接写入数据到内存空间里面，下图为其内存分配策略。</p> <p><img src="/blog/imgs/03%E6%8A%80%E6%9C%AF/nodebuffer/1.jpg" alt="alt text"></p> <p>图，如果当前存储了 2KB 的数据，后面要存储 5KB 大小数据的时候分配池判断所需内存空间大于 4KB，则会去重新申请内存空间来存储 5KB 数据并且分配池的当前偏移指针也是指向新申请的内存空间，这时候就之前剩余的 6KB(8KB-2KB)内存空间就会被搁置。至于为什么会用8KB作为存储单元分配，为什么大于8KB按照大内存分配策略，在下面Buffer内存分配机制优点有说明。</p> <p><strong>分配大内存</strong></p> <p>还是看上面那张内存分配图，如果需要超过8KB的Buffer对象，将会直接分配一个SlowBuffer对象作为基础单元，这个基础单元将会被这个大Buffer对象独占。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Big buffer,just alloc one</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SlowBuffer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>这里的<strong>SlowBUffer</strong>类实在<strong>C++<strong>中定义的，虽然引用 <strong>buffer</strong> 模块可以访问到它，但是不推荐直接操作它，而是用</strong>Buffer</strong>替代。这里内部parent属性指向的<strong>SlowBuffer</strong>对象来自Node自身<strong>C++<strong>中的定义，是</strong>C++<strong>层面的</strong>Buffer</strong>对象，所用内存不在V8的堆中</p> <p><strong>内存分配的限制</strong></p> <p>此外，<strong>Buffer</strong>单次的内存分配也有限制，而这个限制根据不同操作系统而不同，而这个限制可以看到<strong>node_buffer.h</strong>里面</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">static</span> <span class="token keyword">const</span> unsigned int kMaxLength <span class="token operator">=</span>
<span class="token function">sizeof</span><span class="token punctuation">(</span>int32_t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>intptr_t<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0x3fffffff</span> <span class="token operator">:</span> <span class="token number">0x7fffffff</span><span class="token punctuation">;</span>
</code></pre></div><p>对于 32 位的操作系统单次可最大分配的内存为 1G，对于 64 位或者更高的为 2G。</p> <p><strong>buffer 内存分配机制优点</strong></p> <p><strong>Buffer</strong>真正的内存实在<strong>Node</strong>的<strong>C++<strong>层面提供的，<strong>JavaScript</strong>层面只是使用它。当进行小而频繁的</strong>Buffer</strong>操作时，采用的是<strong>8KB</strong>为一个单元的机制进行预先申请和事后分配，使得<strong>Javascript</strong>到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的<strong>Buffer</strong>而言(大于<strong>8KB</strong>)，则直接使用**C++**层面提供的内存，则无需细腻的分配操作。</p> <p><strong>Buffer 对象分配</strong></p> <p>以下代码示例，在加载时直接调用了 createPool() 相当于直接初始化了一个 8 KB 的内存空间，这样在第一次进行内存分配时也会变得更高效。另外在初始化的同时还初始化了一个新的变量 poolOffset = 0 这个变量会记录已经使用了多少字节。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Buffer<span class="token punctuation">.</span>poolSize <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> poolSize<span class="token punctuation">,</span> poolOffset<span class="token punctuation">,</span> allocPool<span class="token punctuation">;</span><span class="token operator">...</span> <span class="token comment">// 中间代码省略</span>
<span class="token keyword">function</span> <span class="token function">createPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  poolSize <span class="token operator">=</span> Buffer<span class="token punctuation">.</span>poolSize<span class="token punctuation">;</span>  
  allocPool <span class="token operator">=</span> <span class="token function">createUnsafeArrayBuffer</span><span class="token punctuation">(</span>poolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  poolOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">createPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 129 行</span>
</code></pre></div><p>此时，新构造的 slab 如下所示：</p> <p><img src="/blog/imgs/03%E6%8A%80%E6%9C%AF/nodebuffer/4.webp" alt="alt text"></p> <p>现在让我们来尝试分配一个大小为 2048 的 Buffer 对象，代码如下所示：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span>
</code></pre></div><p>现在让我们先看下当前的 slab 内存是怎么样的？如下所示：</p> <p><img src="/blog/imgs/03%E6%8A%80%E6%9C%AF/nodebuffer/5.webp" alt="alt text"></p> <p>那么这个分配过程是怎样的呢？让我们再看 buffer.js 另外一个核心的方法 allocate(size)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// https://github.com/nodejs/node/blob/v10.x/lib/buffer.js#L318</span>
<span class="token keyword">function</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FastBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 当分配的空间小于 Buffer.poolSize 向右移位，这里得出来的结果为 4KB</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> <span class="token punctuation">(</span>Buffer<span class="token punctuation">.</span>poolSize <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token punctuation">(</span>poolSize <span class="token operator">-</span> poolOffset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">createPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FastBuffer</span><span class="token punctuation">(</span>allocPool<span class="token punctuation">,</span> poolOffset<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    poolOffset <span class="token operator">+=</span> size<span class="token punctuation">;</span> <span class="token comment">// 已使用空间累加    </span>
    <span class="token function">alignPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8 字节内存对齐处理</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
      <span class="token comment">// C++ 层面申请return createUnsafeBuffer(size);}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>读完上面的代码，已经很清晰的可以看到何时会分配小 Buffer 对象，又何时会去分配大 Buffer 对象。</p> <h3 id="buffer-内存分配总结"><a href="#buffer-内存分配总结" class="header-anchor">#</a> Buffer 内存分配总结</h3> <p>这块内容着实难理解，翻了几本 Node.js 相关书籍，朴灵大佬的「深入浅出 Node.js」Buffer 一节还是讲解的挺详细的，推荐大家去阅读下。</p> <ol><li>在初次加载时就会初始化 1 个 <strong>8KB 的内存空间</strong>，buffer.js 源码有体现</li> <li>根据申请的内存大小分为<strong>小 Buffer 对象</strong> 和 <strong>大 Buffer 对象</strong></li> <li>小 Buffer 情况，会继续判断这个 slab 空间是否足够</li></ol> <ul><li>如果空间足够就去使用剩余空间同时更新 slab 分配状态，偏移量会增加</li> <li>如果空间不足，slab 空间不足，就会去创建一个新的 slab 空间用来分配</li> <li>大 Buffer 情况，则会直接走 createUnsafeBuffer(size) 函数</li> <li>不论是小 Buffer 对象还是大 Buffer 对象，内存分配是在 C++ 层面完成，内存管理在 JavaScript 层面，最终还是可以被 V8 的垃圾回收标记所回收。</li></ul> <h3 id="buffer应用场景"><a href="#buffer应用场景" class="header-anchor">#</a> Buffer应用场景</h3> <p><strong>I/O 操作</strong></p> <p>关于 I/O 可以是文件或网络 I/O，以下为通过流的方式将 input.txt 的信息读取出来之后写入到 output.txt 文件，关于 Stream 与 Buffer 的关系不明白的在回头看下 Buffer 初识 一节讲解的 什么是Stream?、 什么是Buffer?</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> inputStream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建可读流</span>
<span class="token keyword">const</span> outputStream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">'output.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建可写流</span>
inputStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 管道读写</span>
</code></pre></div><p>在 Stream 中我们是不需要手动去创建自己的缓冲区，在 Node.js 的流中将会自动创建。</p> <p><strong>zlib.js</strong></p> <p>zlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压功能。参考源代码 zlib.js 源码</p> <p><strong>加解密</strong></p> <p>在一些加解密算法中会遇到使用 Buffer，例如 crypto.createCipheriv 的第二个参数 key 为 String 或 Buffer 类型，如果是 Buffer 类型，就用到了本篇我们讲解的内容，以下做了一个简单的加密示例，重点使用了 Buffer.alloc() 初始化一个实例（这个上面有介绍），之后使用了 fill 方法做了填充，这里重点在看下这个方法的使用。</p> <p>buf.fill(value[, offset[, end]][, encoding])</p> <ul><li>value: 第一个参数为要填充的内容</li> <li>offset: 偏移量，填充的起始位置</li> <li>end: 结束填充 buf 的偏移量</li> <li>encoding: 编码集</li></ul> <p><strong>以下为 Cipher 的对称加密 Demo</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> iv<span class="token punctuation">,</span> algorithm<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> cipherEncoding<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a123456789'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'aes-128-ecb'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">,</span> <span class="token string">'base64'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">handleKey</span> <span class="token operator">=</span> <span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token keyword">const</span> bytes <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化一个 Buffer 实例，每一项都用 00 填充    </span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;    </span>
  bytes<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 填充    </span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;Buffer 61 31 32 33 34 35 36 37 38 39 00 00 00 00 00 00&gt;</span>
  <span class="token keyword">return</span> bytes<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> cipher <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">createCipheriv</span><span class="token punctuation">(</span>algorithm<span class="token punctuation">,</span> <span class="token function">handleKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> iv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> crypted <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">'Node.js 技术栈'</span><span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> cipherEncoding<span class="token punctuation">)</span><span class="token punctuation">;</span>    
crypted <span class="token operator">+=</span> cipher<span class="token punctuation">.</span><span class="token function">final</span><span class="token punctuation">(</span>cipherEncoding<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>crypted<span class="token punctuation">)</span> <span class="token comment">// jE0ODwuKN6iaKFKqd3RF4xFZkOpasy8WfIDl8tRC5t0=</span>
</code></pre></div><h3 id="buffer-vs-cache"><a href="#buffer-vs-cache" class="header-anchor">#</a> Buffer VS Cache</h3> <p><strong>缓冲（Buffer）</strong></p> <p>缓冲（Buffer）是用于处理二进制流数据，将数据缓冲起来，它是临时性的，对于流式数据，会采用缓冲区将数据临时存储起来，等缓冲到一定的大小之后在存入硬盘中。视频播放器就是一个经典的例子，有时你会看到一个缓冲的图标，这意味着此时这一组缓冲区并未填满，当数据到达填满缓冲区并且被处理之后，此时缓冲图标消失，你可以看到一些图像数据。</p> <p><strong>缓存（Cache）</strong></p> <p>缓存（Cache）我们可以看作是一个中间层，它可以是永久性的将热点数据进行缓存，使得访问速度更快，例如我们通过 Memory、Redis 等将数据从硬盘或其它第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也是性能优化一个重要的点。</p> <h3 id="buffer-vs-string"><a href="#buffer-vs-string" class="header-anchor">#</a> Buffer VS String</h3> <p>通过压力测试来看看 String 和 Buffer 两者的性能如何？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      s<span class="token operator">+=</span><span class="token string">'a'</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> str <span class="token operator">=</span> s<span class="token punctuation">;</span>
<span class="token keyword">const</span> bufStr <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/buffer'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>bufStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>以上实例我放在虚拟机里进行测试，你也可以在本地电脑测试，使用 AB 测试工具。</p> <p><strong>测试 string</strong></p> <p>看以下几个重要的参数指标，之后通过 buffer 传输进行对比</p> <ul><li>Complete requests: 21815</li> <li>Requests per second: 363.58 [#/sec] (mean)</li> <li>Transfer rate: 3662.39 [Kbytes/sec] received</li></ul> <div class="language-cmd extra-class"><pre class="language-text"><code>$ ab -c 200-t 60 http://192.168.6.131:3000/string
</code></pre></div><p><img src="/blog/imgs/03%E6%8A%80%E6%9C%AF/nodebuffer/6.webp" alt="alt text"></p> <p><strong>测试 buffer</strong></p> <p>可以看到通过 buffer 传输总共的请求数为 50000、QPS 达到了两倍多的提高、每秒传输的字节为 9138.82 KB，从这些数据上可以证明提前将数据转换为 Buffer 的方式，可以使性能得到近一倍的提升。</p> <ul><li>Complete requests: 50000</li> <li>Requests per second: 907.24 [#/sec] (mean)</li> <li>Transfer rate: 9138.82 [Kbytes/sec] received</li></ul> <div class="language-cmd extra-class"><pre class="language-text"><code>$ ab -c 200-t 60 http://192.168.6.131:3000/buffer
</code></pre></div><p><img src="/blog/imgs/03%E6%8A%80%E6%9C%AF/nodebuffer/7.webp" alt="alt text"></p> <p>在 HTTP 传输中传输的是二进制数据，上面例子中的 /string 接口直接返回的字符串，这时候 HTTP 在传输之前会先将字符串转换为 Buffer 类型，以二进制数据传输，通过流（Stream）的方式一点点返回到客户端。但是直接返回 Buffer 类型，则少了每次的转换操作，对于性能也是有提升的。</p> <p>在一些 Web 应用中，对于静态数据可以预先转为 Buffer 进行传输，可以有效减少 CPU 的重复使用（重复的字符串转 Buffer 操作）。</p></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2/23/2024, 9:09:24 AM</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/5fbc21/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">TypeScript结构类型和Freshness</div></a> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/5fbc21/" class="prev">TypeScript结构类型和Freshness</a></span> <!----></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/e18f26/"><div>
            简易webpack打包器
            <!----></div></a> <span class="date">04-16</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/b086bd/"><div>
            JS模块化规范笔记
            <!----></div></a> <span class="date">04-10</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/5fbc21/"><div>
            TypeScript结构类型和Freshness
            <!----></div></a> <span class="date">04-07</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.4a3d1442.js" defer></script><script src="/blog/assets/js/2.e2e64146.js" defer></script><script src="/blog/assets/js/23.998636e7.js" defer></script>
  </body>
</html>
